---
description: 
globs: 
alwaysApply: true
---
# Main Rule
You are a Java expert.

## Build Configuration
- Java Version: 21
- Maven multi-module project

## Dependencies
- Core dependencies are managed in the parent POM
- Module-specific dependencies are declared in their respective POMs
- Inter-module dependencies use `${project.version}` for version management

## When asked to implement a task
- Always review [implementation-tasks.mdc](mdc:.cursor/specifications/implementation-tasks.mdc) when asked to implement a task.

## Project Structure
Review [project-structure.mdc](mdc:.cursor/specifications/project-structure.mdc) for project struture.

## Project Specifications
Review [main-project-specifications.mdc](mdc:.cursor/specifications/main-project-specifications.mdc) for project specifications.

## Module Creation Guidelines
[module-creation.mdc](mdc:.cursor/rules/module-creation.mdc)

## Implementation Patterns
### State Management
- Implement state containers (e.g., GameState, Player) as immutable where possible
- Use dedicated synchronization methods for state sharing:
  ```java
  public void copyState(Player other) {
      this.balance = other.balance;
      this.currentBet = other.currentBet;
  }
  ```
- Validate state transitions using dedicated validator classes
- Document state invariants in class/method JavaDoc
- Ensure state synchronization happens in the correct order:
  ```java
  public boolean startNewRound(double betAmount) {
      resetRound();  // Reset state first
      if (!moveValidator.isValidBet((int)betAmount)) {
          return false;
      }
      if (!player.placeBet((int)betAmount)) {
          return false;
      }
      // Update game engine state after successful bet
      gameEngine.getPlayer().copyState(player);
      // Create new validator with updated state
      this.moveValidator = new MoveValidator(gameEngine.getGameState(), gameEngine.getPlayer());
      return true;
  }
  ```
- Handle state validation failures gracefully:
  ```java
  try {
      int roll = controller.roll();
      // Process roll result
  } catch (IllegalStateException e) {
      // Handle invalid state gracefully
      view.showRoundOutcome(false, bet);
      return;
  }
  ```

### Controller Implementation
- Use composition over inheritance for component coordination
- Implement validators as separate classes for reusability:
  ```java
  public class MoveValidator {
      private final GameState state;
      private final Player player;
      // Validation methods...
  }
  ```
- Handle state synchronization in controller methods:
  ```java
  public void resetRound() {
      gameEngine.resetGame();
      gameEngine.getPlayer().copyState(player);
  }
  ```
- Throw specific exceptions for invalid operations
- Ensure validators are updated when state changes:
  ```java
  // After state changes that affect validation
  this.moveValidator = new MoveValidator(updatedState, updatedPlayer);
  ```
- Maintain clear state ownership:
  - Controller owns the coordination
  - Game engine owns the game logic
  - Player owns player state
  - Validators own validation logic

### Testing Patterns
- Use `@BeforeEach` for test state setup
- Implement repeated tests for random operations:
  ```java
  @RepeatedTest(100)
  void testMultipleRollsStayInValidRange() {
      // Test implementation
  }
  ```
- Test state synchronization:
  ```java
  @Test
  void testStateSync() {
      player.placeBet(10);
      gameEngine.getPlayer().copyState(player);
      assertEquals(player.getBalance(), gameEngine.getPlayer().getBalance());
  }
  ```
- Test both valid and invalid game flows
- Test error handling:
  ```java
  @Test
  void testInvalidStateHandling() {
      // Set up invalid state
      assertThrows(IllegalStateException.class, () -> controller.roll());
  }
  ```

## Module Creation Guidelines
[module-creation.mdc](mdc:.cursor/rules/module-creation.mdc)

## State Management
- Each module should maintain its own state independently
- When sharing state between modules:
  - Use clear ownership boundaries
  - Implement state synchronization methods (e.g., `copyState`)
  - Document state dependencies and synchronization requirements
  - Validate state consistency in tests
  - Ensure state synchronization after state-changing operations
  - Use appropriate state checks (e.g., game status vs game over)
  - Example state synchronization pattern:
    ```java
    public int performStateChangingOperation() {
        int result = gameEngine.operation();
        player.copyState(gameEngine.getPlayer());
        return result;
    }
    ```
  - Example state validation pattern:
    ```java
    public boolean checkGameState() {
        return gameState.getStatus() != Status.PLAYING;  // Check specific state
    }
    ```

## Controller Design
- Controllers should:
  - Coordinate between core components
  - Validate game actions using dedicated validators
  - Maintain state consistency across components
  - Provide clear, well-documented public APIs
  - Handle errors gracefully with appropriate exceptions
  - Include comprehensive test coverage

## Testing Guidelines
- Test both success and failure cases
- Verify state consistency after operations
- Use repeated tests for randomized operations
- Test edge cases and invalid inputs
- Ensure proper cleanup in test teardown
- Test state synchronization between modules
- State validation testing patterns:
  - Test state transitions and phase changes
  - Verify state synchronization after operations
  - Check specific state flags rather than derived conditions
  - Example state validation test:
    ```java
    @Test
    void testStateTransition() {
        controller.startNewRound(10);
        int roll = controller.roll();
        
        if (roll == 7 || roll == 11) {
            assertTrue(controller.isRoundOver());
            assertEquals(Status.WIN, controller.getGameState().getStatus());
        } else if (roll == 2 || roll == 3 || roll == 12) {
            assertTrue(controller.isRoundOver());
            assertEquals(Status.LOSE, controller.getGameState().getStatus());
        } else {
            assertFalse(controller.isRoundOver());
            assertEquals(Status.PLAYING, controller.getGameState().getStatus());
        }
    }
    ```
- Module-specific test execution:
  - Tests are organized by module (e.g., controller, core, cli)
  - Run specific tests using: `mvn test -Dtest=TestClass#testMethod`
  - Always run tests from the module directory containing the test
  - Example: `cd controller && mvn test -Dtest=GameControllerTest#testValidGameFlow`




